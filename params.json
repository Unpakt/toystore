{"name":"Toystore","tagline":"An object mapper for anything that can read, write and delete data.","body":"# Toystore\r\n\r\nAn object mapper for any [adapter](https://github.com/jnunemaker/adapter) that can read, write, delete, and clear data.\r\n\r\n## Examples\r\n\r\nThe project comes with two main includes that you can use -- Toy::Object and Toy::Store.\r\n\r\n**Toy::Object** comes with all the goods you need for plain old ruby objects -- attributes, dirty attribute tracking, equality, inheritance, serialization, cloning, logging and pretty inspecting.\r\n\r\n**Toy::Store** includes Toy::Object and adds identity, persistence and querying through adapters, mass assignment, callbacks, validations and a few simple associations (lists and references).\r\n\r\n### Toy::Object\r\n\r\nFirst, join me in a whirlwind tour of Toy::Object.\r\n\r\n```ruby\r\nclass Person\r\n  include Toy::Object\r\n\r\n  attribute :name, String\r\n  attribute :age,  Integer\r\nend\r\n\r\n# Pretty class inspecting\r\npp Person\r\n\r\njohn  = Person.new(:name => 'John',  :age => 30)\r\nsteve = Person.new(:name => 'Steve', :age => 31)\r\n\r\n# Pretty inspecting\r\npp john\r\n\r\n# Attribute dirty tracking\r\njohn.name = 'NEW NAME!'\r\npp john.changes       # {\"name\"=>[\"John\", \"NEW NAME!\"], \"age\"=>[nil, 30]}\r\npp john.name_changed? # true\r\n\r\n# Equality goodies\r\npp john.eql?(john)  # true\r\npp john.eql?(steve) # false\r\npp john == john     # true\r\npp john == steve    # false\r\n\r\n# Cloning\r\npp john.clone\r\n\r\n# Inheritance\r\nclass AwesomePerson < Person\r\nend\r\n\r\npp Person.attributes.keys.sort          # [\"age\", \"name\"]\r\npp AwesomePerson.attributes.keys.sort   # [\"age\", \"name\", \"type\"]\r\n\r\n# Serialization\r\nputs john.to_json\r\nputs john.to_xml\r\n```\r\n\r\nOk, that was definitely awesome. Please continue on your personal journey to a blown mind (very similar to a beautiful mind).\r\n\r\n### Toy::Store\r\n\r\nToy::Store is a unique bird that builds on top of Toy::Object. Below is a quick sample of what it can do.\r\n\r\n```ruby\r\nclass Person\r\n  include Toy::Store\r\n\r\n  attribute :name, String\r\n  attribute :age,  Integer, :default => 0\r\nend\r\n\r\n# Persistence\r\njohn = Person.create(:name => 'John', :age => 30)\r\npp john\r\npp john.persisted?\r\n\r\n# Mass Assignment Security\r\nPerson.attribute :role, String, :default => 'guest'\r\nPerson.attr_accessible :name, :age\r\n\r\nperson = Person.new(:name => 'Hacker', :age => 13, :role => 'admin')\r\npp person.role # \"guest\"\r\n\r\n# Querying\r\npp Person.read(john.id)\r\npp Person.read_multiple([john.id])\r\npp Person.read('NOT HERE') # nil\r\n\r\nbegin\r\n  Person.read!('NOT HERE')\r\nrescue Toy::NotFound\r\n  puts \"Could not find person with id of 'NOT HERE'\"\r\nend\r\n\r\n# Reloading\r\npp john.reload\r\n\r\n# Callbacks\r\nclass Person\r\n  before_create :add_fifty_to_age\r\n\r\n  def add_fifty_to_age\r\n    self.age += 50\r\n  end\r\nend\r\n\r\npp Person.create(:age => 10).age # 60\r\n\r\n# Validations\r\nclass Person\r\n  validates_presence_of :name\r\nend\r\n\r\nperson = Person.new\r\npp person.valid?        # false\r\npp person.errors[:name] # [\"can't be blank\"]\r\n\r\n# Lists (array key stored as attribute)\r\nclass Skill\r\n  include Toy::Store\r\n\r\n  attribute :name, String\r\n  attribute :truth, Boolean\r\nend\r\n\r\nclass Person\r\n  list :skills, Skill\r\nend\r\n\r\njohn.skills = [Skill.create(:name => 'Programming', :truth => true)]\r\njohn.skills << Skill.create(:name => 'Mechanic', :truth => false)\r\n\r\npp john.skills.map(&:id) == john.skill_ids # true\r\n\r\n# References (think foreign keyish)\r\nclass Person\r\n  reference :mom, Person\r\nend\r\n\r\nmom = Person.create(:name => 'Mum')\r\njohn.mom = mom\r\njohn.save\r\npp john.reload.mom_id == mom.id # true\r\n\r\n# Identity Map\r\nToy::IdentityMap.use do\r\n  frank = Person.create(:name => 'Frank')\r\n\r\n  pp Person.read(frank.id).equal?(frank)                # true\r\n  pp Person.read(frank.id).object_id == frank.object_id # true\r\nend\r\n\r\n# Or you can turn it on globally\r\nToy::IdentityMap.enabled = true\r\nfrank = Person.create(:name => 'Frank')\r\n\r\npp Person.read(frank.id).equal?(frank)                # true\r\npp Person.read(frank.id).object_id == frank.object_id # true\r\n\r\n# All persistence runs through an adapter.\r\n# All of the above examples used the default in-memory adapter.\r\n# Looks something like this:\r\nPerson.adapter :memory, {}\r\n\r\nputs \"Adapter: #{Person.adapter.inspect}\"\r\n\r\n# You can make a new adapter to your awesome new/old data store\r\nAdapter.define(:append_only_array) do\r\n  def read(key)\r\n    if (record = client.reverse.detect { |row| row[0] == key })\r\n      record\r\n    end\r\n  end\r\n\r\n  def write(key, value)\r\n    client << [key, value]\r\n    value\r\n  end\r\n\r\n  def delete(key)\r\n    client.delete_if { |row| row[0] == key }\r\n  end\r\n\r\n  def clear\r\n    client.clear\r\n  end\r\nend\r\n\r\nclient = []\r\nPerson.adapter :append_only_array, client\r\n\r\npp \"Client: #{Person.adapter.client.equal?(client)}\"\r\n\r\nperson = Person.create(:name => 'Phil', :age => 55)\r\nperson.age = 56\r\nperson.save\r\n\r\npp client\r\n\r\npp Person.read(person.id) # Phil with age 56\r\n```\r\n\r\nIf that doesn't excite you, nothing will. At this point, you are probably wishing for more.\r\n\r\nLuckily, there is an entire directory full of [examples](https://github.com/jnunemaker/toystore/tree/master/examples) and I created a few power user guides, which I will kindly link next.\r\n\r\n## Instrumentation\r\n\r\nToyStore comes with a log subscriber and automatic metriks instrumentation. By\r\ndefault these work with ActiveSupport::Notifications, but only require the\r\npieces of ActiveSupport that are needed and only do so if you actually attempt\r\nto require the instrumentation files listed below.\r\n\r\nTo use the log subscriber:\r\n\r\n```ruby\r\n# Gemfile\r\ngem 'activesupport'\r\n\r\n# config/initializers/toystore.rb (or wherever you want it)\r\nrequire 'toy/instrumentation/log_subscriber'\r\n```\r\n\r\nTo use the metriks instrumentation:\r\n\r\n```ruby\r\n# Gemfile\r\ngem 'activesupport'\r\ngem 'metriks'\r\n\r\n# config/initializers/toystore.rb (or wherever you want it)\r\nrequire 'toy/instrumentation/metriks'\r\n```\r\n\r\n## ToyStore Power User Guides\r\n\r\n* [Wiki Home](https://github.com/jnunemaker/toystore/wiki)\r\n* [Identity](https://github.com/jnunemaker/toystore/wiki/Identity)\r\n* [Types](https://github.com/jnunemaker/toystore/wiki/Types)\r\n* [Exceptions](https://github.com/jnunemaker/toystore/wiki/Exceptions)\r\n\r\n## Changelog\r\n\r\nAs of 0.8.3, I started keeping a [changelog](https://github.com/jnunemaker/toystore/blob/master/Changelog.md). All significant updates will be summarized there.\r\n\r\n## Compatibility\r\n\r\n* Rails 3.0.*, 3.1.*, 3.2.*, Sinatra, etc. No Rails 2 (because it uses Active Model).\r\n* Ruby 1.9.3 only\r\n\r\n## Mailing List\r\n\r\nhttps://groups.google.com/forum/#!forum/toystoreadapter\r\n\r\n## Contributing\r\n\r\n* Fork the project.\r\n* Make your feature addition or bug fix in a topic branch.\r\n* Add tests for it. This is important so we don't break it in a future version unintentionally.\r\n* Commit, do not mess with rakefile, version, or changelog. (if you want to have your own version, that is fine, but bump version in a commit by itself so we can ignore when we pull)\r\n* Send a pull request.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}